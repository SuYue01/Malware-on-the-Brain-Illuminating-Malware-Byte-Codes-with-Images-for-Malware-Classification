import os
import glob
import numpy as np
import cv2
from img_gist_feature.utils_gist import *
import time
import random
from sklearn.model_selection import StratifiedKFold
from sklearn.metrics import confusion_matrix, classification_report
from sklearn.neighbors import KNeighborsClassifier
import matplotlib.pyplot as plt
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.layers import Conv2D, MaxPooling2D
from tensorflow.keras.layers import Flatten
from tensorflow.keras.optimizers import SGD
from tensorflow.keras.layers import Dropout
from tensorflow.keras.layers import Activation
from tensorflow.keras import losses
from tensorflow.keras.layers import BatchNormalization
from tensorflow.keras.layers import LeakyReLU
from keras import regularizers
import keras
import tensorflow as tf
from tensorflow.python.framework import ops
ops.reset_default_graph()
import warnings
warnings.filterwarnings('ignore')
tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
gist_helper = GistUtils()
def transition_matrix(arr, n=1):
    """"
    Computes the transition matrix from Markov chain sequence of order `n`.

    :param arr: Discrete Markov chain state sequence in discrete time with states in 0, ..., N
    :param n: Transition order
    """

    M = np.zeros(shape=(256, 256))
    for (i, j) in zip(arr, arr[1:]):
        M[i, j] += 1
    #print(M.sum())
    M_sum = np.ma.masked_equal(M.sum(axis=1), 0)
    T = (M.T / M_sum).T

    return np.linalg.matrix_power(T, n)


def num_img_fams_list():
  inp_dir = 'C:/Users/zhong/Downloads/malimg_dataset/malimg_paper_dataset_imgs/'
  os.chdir(inp_dir)  #the parent fold with sub-folders
  list_fams = os.listdir(os.getcwd()) #vector of strings with family names
  no_imgs = [] # No. of samples per family

  for family in range(len(list_fams)):
     os.chdir(list_fams[family])
     no_per_family = len(glob.glob('*.png'))
     no_imgs.append(no_per_family)
     os.chdir('..')
  return no_imgs, list_fams


def getlabels(no_imgs, total):
    y = np.zeros(total) #label vector
    temp1 = np.zeros(len(no_imgs)+1)
    temp1[1:len(temp1)] = no_imgs #transform list to ndarray
    temp2 = int(temp1[0]) #used to be as lower bound, initially 0

    for label in range(len(no_imgs)):
       temp3 = temp2 + int(temp1[label+1]) #No. of imgs assigned labels from 2 round
       #print("temp3", temp3)
       #print("label", label)
       for index in range(temp2, temp3):# assigned labels to a fam of malware
            y[index] = label
       temp2 = temp2 + int(temp1[label + 1])
    #print(y[100:200])
    return np.array(y)


def getX(list_fams, total):
   trans_mat_arr = list() #pixel ranges between 0 and 255, in total 256
   total_time = 0
   min_time = 10
   for i in range(len(list_fams)):
      os.chdir(list_fams[i])
      img_list = glob.glob('*.png')# Getting only 'png' files in a folder
      for j in range(len(img_list)):
         img = cv2.imread(img_list[j], 0).flatten()

         tic = time.perf_counter()
         np_gist = transition_matrix(img)
         #print(np_gist.shape)
         toc = time.perf_counter()
         fir_step_time = toc - tic

         total_time = total_time + fir_step_time
         if fir_step_time < min_time:
             min_time = fir_step_time
         trans_mat_arr.append(np_gist)
         #print(f"the period of calling transition_matrix function in {fir_step_time:0.4f} seconds")
      os.chdir('..')
   print(f"the average time per image {total_time / total:0.4f} seconds")
   print(f"the fewest time taken for an image {min_time:0.4f} seconds")
   return np.array(trans_mat_arr)


def strtifiedkfolddata(X, y, total, kfold):

    #p = np.arange(total)# an index array, 0:n_samples
    #random.seed(random.random())
    #random.shuffle(p)# the index array is now shuffled
    #X_shuffle, y_shuffle = X[p], y[p]# both the arrays are now shuffled
    skf = StratifiedKFold(kfold)
    #print("skf.get_n_splits", skf.get_n_splits(X, y))
    skfind = [None]*skf.get_n_splits(X, y)# indices
    cnt = 0
    for train_index in skf.split(X, y):
       skfind[cnt] = train_index
       cnt = cnt + 1
    #print("train_shuffle", skfind[0][0][100:200])
    #print("test_shuffle", skfind[0][1][100:200])
    #print("y_train_shuffle", y[skfind[0][0][100:200]])
    #print("y_shuffle", y[skfind[0][1][100:200]])
    return skfind


def model_cnn(no_imgs):
    model = Sequential()
    model.add(Conv2D(64, (3, 3),
                      activation='relu',
                      padding='same',
                      name='block1_conv1',
                     input_shape=(256, 256, 1)))  # 256,256,64
    model.add(Conv2D(64, (3, 3),
                      activation='relu',
                      padding='same',
                      name='block1_conv2'))  # 256,256,64
    model.add(MaxPooling2D((2, 2), strides=(2, 2), name='block1_pool')) #128, 128, 64

    model.add(Conv2D(128, (3, 3),
                      activation='relu',
                      padding='same',
                      name='block2_conv1')) #128,128, 128
    model.add(Conv2D(128, (3, 3),
                      activation='relu',
                      padding='same',
                      name='block2_conv2')) #128,128, 128
    model.add(MaxPooling2D((2, 2), strides=(2, 2), name='block2_pool')) #64， 64，128

    model.add(Conv2D(256, (3, 3),
                      activation='relu',
                      padding='same',
                      name='block3_conv1')) #64， 64，256
    model.add(Conv2D(256, (3, 3),
                      activation='relu',
                      padding='same',
                      name='block3_conv2')) #64， 64，256
    model.add(Conv2D(256, (3, 3),
                      activation='relu',
                      padding='same',
                      name='block3_conv3')) #64， 64，256
    model.add(MaxPooling2D((2, 2), strides=(2, 2), name='block3_pool')) #32， 32，256

    model.add(Conv2D(512, (3, 3),
                      activation='relu',
                      padding='same',
                      name='block4_conv1')) #32， 32，512
    model.add(Conv2D(512, (3, 3),
                      activation='relu',
                      padding='same',
                      name='block4_conv2')) #32， 32，512
    model.add(Conv2D(512, (3, 3),
                      activation='relu',
                      padding='same',
                      name='block4_conv3')) #32， 32，512
    model.add(MaxPooling2D((2, 2), strides=(2, 2), name='block4_pool')) #16， 16，512

    model.add(Conv2D(512, (3, 3),
                      activation='relu',
                      padding='same',
                      name='block5_conv1')) #16， 16，512
    model.add(Conv2D(512, (3, 3),
                      activation='relu',
                      padding='same',
                      name='block5_conv2')) #16， 16，512
    model.add(Conv2D(512, (3, 3),
                      activation='relu',
                      padding='same',
                      name='block5_conv3')) #16， 16，512
    model.add(MaxPooling2D((2, 2), strides=(2, 2), name='block5_pool')) #8， 8，51

    model.add(Flatten())
    model.add(Dense(1024))
    model.add(Dense(len(no_imgs)))
    model.add(Activation('softmax'))
    return model

def train():
    no_imgs, list_fams = num_img_fams_list() #a list storing num of images for each family
    print(no_imgs)
    total = sum(no_imgs) # total number of all samples
    print(total)
    X = getX(list_fams, total)
    y = getlabels(no_imgs, total)

    p = np.arange(total)  # an index array, 0:n_samples
    random.seed(random.random())
    random.shuffle(p)  # the index array is now shuffled
    X, y = X[p], y[p]  # both the arrays are now shuffled
    #print("y.shape", y.shape)
    kfold = 10# no. of folds (better to have this at the start of the code)
    skfind = strtifiedkfolddata(X, y, total, kfold)
    cvscores = []

    for i in range(kfold):
        train_indices = skfind[i][0]
        #print("train_indices", train_indices[100:200])
        test_indices = skfind[i][1]
        #print(test_indices[100:200])
        X_train = X[train_indices].reshape((-1, 256, 256, 1)).astype(float)
        #print("X_train.shape", X_train.shape)
        y_train = y[train_indices]
        y_train_onehot = keras.utils.to_categorical(y_train, num_classes=len(no_imgs))
        #print(y_train[100:200])
        #print("y_train.shape", y_train.shape)
        X_test = X[test_indices].reshape((-1, 256, 256, 1)).astype(float)
        y_test = y[test_indices]
        #print(y_test[100:200])
        y_test_onehot = keras.utils.to_categorical(y_test, num_classes=len(no_imgs))

        model = model_cnn(no_imgs)
        # Compile model
        model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

        # Fit the model
        model.fit(X_train, y_train_onehot, epochs=1, batch_size=1, verbose=1)

        # evaluate the model
        scores = model.evaluate(X_test, y_test_onehot, verbose=1)
        print("%s: %.2f%%" % (model.metrics_names[1], scores[1] * 100))
        cvscores.append(scores[1] * 100)

        avg_acc = np.mean(cvscores)
        print("avg_acc:", avg_acc)

        # Testing
        tic = time.time()
        y_predict = model.predict(X_test)  # output is labels and not indices
        toc = time.time()
        print("testing time = ", toc - tic)  # roughly 0.3 secs
        y_predict = np.argmax(y_predict, axis=1)
        print(y_predict[0:100])
        print(y_test[0:100])
        # Compute confusion matrixnp.array([label.index(max(label)) for label in y_predict.tolist()])
        print('Confusion Matrix')
        print(confusion_matrix(y_test, y_predict))
        print('Classification Report')
        print(classification_report(y_test, y_predict, target_names=list_fams))


if __name__ == "__main__":
          train()
          #no_imgs, list_fams = num_img_fams_list()
          #total = sum(no_imgs)
          #X = getX(list_fams, total)
          #print(X.shape)
